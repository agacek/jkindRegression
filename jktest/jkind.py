'''
This module contains the JKind class for execution and 
collection of the results.

'''

import os
import re
import subprocess
import xml.dom.minidom
from .results import JKindResult
from .results import ResultList
from .results import ExceptionReport


class JKind( object ):
    '''
    **Public Class**
    
    This class performs the command line call to execute JKind on the desired
    file and argument set and collects the results.

    '''

    def __init__( self,
                  fname,
                  arg,
                  jkindPath = None,
                  javaPath = None,
                  quiet = False ):
        '''
        :param fname: lustre filename to run
        :type fname: str
        :param arg: arguments to execute
        :type arg: str
        :param jkindPath: Optional alternate JKind jar to execute.
        :type jkindPath: str
        :param quiet: Optional flag to suppress non-failing output errors
        :type quiet: boolean

        '''
        self._file = fname
        self._arg = arg
        self._jkindPath = jkindPath
        self._javaPath = javaPath
        self._results = None
        self._exception = None
        self._quiet = quiet


    def run( self ):
        '''
        **Public Method**
        
        Constructs the command line string to run JKind on the file with the
        argument set. Checks the command line string generated by JKind to see
        if JKind actually ran and generated an XML file for us to analyze.
        If JKind ran then parses the XML file to read and collect the results.
        
        :return: n/a:

        '''
        if( self._javaPath == None ):
            java = 'java'
        else:
            java = self._javaPath

        if( self._jkindPath == None ):
            jkind = 'jkind '
        else:
            jkind = '{} -jar {} -jkind '.format( java, self._jkindPath )


        # Execute JKind from the command line
        cmdLine = jkind + self._file + ' -xml ' + self._arg
        print( cmdLine )
        proc = subprocess.Popen( cmdLine,
                                 stdout = subprocess.PIPE,
                                 stderr = subprocess.STDOUT,
                                 shell = True )
        ( out, err ) = proc.communicate()

        if( self._checkOutputErrs( out.decode() ) == True ):
            self._parseXML()


    def getResults( self ):
        '''
        **Public Method**
        
        Getter method for the ResultList containing all the Property results
        stemming from the JKind executions.
        
        :return: ResultList object if JKind has been run, otherwise None.
        :rtype: ResultList *or* None 
        
        '''
        return self._results


    def getException( self ):
        '''
        **Public Method**
        
        Getter method for the ExceptionReport which gives the text of the 
        Java Exception thrown during the JKind execution as well as the
        arguments that were used.
        
        :return: ExceptionReport if exception occurred, otherwise None
        :rtype: ExceptionReport *or* None
        
        '''
        return self._exception


    def _checkOutputErrs( self, string ):
        '''
        **Private Method**
        
        Checks the provided string for one of two things:
         - string doesn't start with 'error', likely indicating invalid
           argument combinations.
         - string doesn't contain a Java Exception
        
        If either of these cases are found will print the string to our
        console/log for later analysis.
        
        If the global quiet flag was set in the Setup Configuration, will
        suppress output prints for errors that are non-failing, such as
        non-supported argument combinations and if proving engines have
        been disabled by the argument combinations.
        
        :param string: String to examine for JKind output errors. Typically 
                       from the JKind command line output.
        :type: str
        
        :return: True if all is well, False otherwise.
        :rtype: bool
        
        '''

        string = string.lower()
        if( string.startswith( 'error' ) == True ):
            self._results = None

            # If selected by cmd line arguments, let's suppress "errors" about
            # "not supported" or "proving engines disabled". Less clutter in
            # the output reports...
            if( self._quiet == True ):
                if( ( string.find( 'not supported with' ) >= 0 ) or
                    ( string.find( 'all proving engines disabled' ) >= 0 ) ):
                    return False

            print( '    >> ' + string )
            return False

        try:
            excp = re.search( 'java.lang.*Exception:', string )
            print( '    >> ERROR: ' + excp.group() )
            self._exception = ExceptionReport()
            self._exception.text = excp.group()
            self._exception.args = self._arg
            return False
        except AttributeError:
            pass

        # Happy path...
        return True


    def _parseXML( self ):
        '''
        **Private Method**

        Constructs the XML results filename from the lustre filename. Opens the
        XML file and reads each of the "Property" elements. Instantiates a
        JKindResult object and stores the "name", "Answer", and "K" value for
        each Property. Appends each JKindResult object to the ResultList 
        member.
        
        If by chance no Properties are generated, will add an "empty" result,
        with the 'name' stating as such and the argument string that caused
        the problem.

        :return: n/a:

        '''

        # Initialize our Results List
        self._results = ResultList()

        # The XML file should be the same name as our *.lus file, just with
        # the xml extension.
        xmlFile = self._file + '.xml'
        assert os.path.exists( xmlFile ) == True, 'XML File Exists?'

        # Get the top level document
        doc = xml.dom.minidom.parse( xmlFile )

        # print( 'READ XML: ' + xmlFile )

        # Get a list of all the XmlProperties elements
        properties = doc.getElementsByTagName( 'Property' )

        for each in properties:

            # Instantiate our data
            res = JKindResult( self._file, self._arg )

            # Get the Name of the XmlProperties
            res['name'] = each.getAttribute( 'name' )


            # Get the Answer attribute. From that get the validity and the source
            # Assumes that there is only one Answer, etc...
            answerAttr = each.getElementsByTagName( 'Answer' )[0]
            res['answer'] = answerAttr.firstChild.data
            # res['source'] = answerAttr.getAttribute( 'source' )

            # Get the K attribute and fill in the value if available
            try:
                kAttr = each.getElementsByTagName( 'K' )[0]
                res['K'] = kAttr.firstChild.data
            except:
                res['K'] = ''

            # Add to our list of Properties
            self._results.append( res )

        # Check that our results list ins't empty. If it is, then add a single
        # empty result so that downstream tests may pass.
        if( len( self._results ) < 1 ):
            empty = JKindResult( self._file, self._arg )
            empty['name'] = '< NO PROPERTY GENERATED for ' + self._arg + '>'
            empty['answer'] = ''
            empty['K'] = ''
            self._results.append( empty )

        # Delete the XML file we generated for this run so we don't get fooled
        # later by a stale file when a jkind run failed.
        try:
            os.remove( xmlFile )
        except:
            pass

        # Sort the list to make equality testing easier later on
        self._results.sort()
